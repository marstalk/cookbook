**关于树有关的算法总结**

对所有的数据结构的遍历，只有两种方式：

- 递归式遍历（所有的递归遍历都可以改造为非递归的形式，因为可以使用栈的数据结构来模拟方法的调用）
- 迭代式遍历

# 一些基础


## 满二叉树
定义：
- 整棵树只有度为0或者2的节点。
- 度为0的接地全部都在**同一层**上。

## 完全二叉树
定义：
- 除了最后一层，其他都已经填满。
- 最后一层的所有叶子节点都集中在**左侧**。

## 二叉搜索树
定义：
- 每一颗子树都符合这个性质：左子树总是小于根节点，右子树总是大于根节点。

## 平衡二叉搜索树
定义：
- 首先它是一颗二叉搜索树。
- 其次它的左右两颗子树的**高度差不超过1**

## 二叉树的存储
1. 链式存储
2. 数组存储，下标为i的节点的左子节点是2\*i+1, 右子节点是2\*i+2

# 遍历方式
二叉树的所有遍历方式可以分为两种：
- 深度优先遍历
  - 前序遍历（递归、迭代）
  - 中序遍历（递归、迭代）
  - 后序遍历（递归、迭代）
- 广度优先遍历
  - 层序遍历（迭代）

## 1 深度优先之递归-前中后序
```java
// DFS
int traverse(TreeNode root){
    if(root == null) return;
    //print(root); preorder // 是不知道左子树，右子树的结果的，
    let x = traverse(root.left);
    //print(root); inorder // 只直到其中一个子树的结果。
    let y = traverse(root.right);

    // 1. 逻辑在放再什么地方（前中后），
    // 2. 逻辑怎么做，要对x，y，root做什么事情。三个重要的信息：x, y, root
    // 3. basecase，什么时候结束。

    //print(root); post order // 直到了左右子树的结果。
}
```
## 2.1 深度优先之迭代-前序
- 使用栈来模拟方法递归调用。
- 下面的例子是先序遍历。

[code](../../javademo/treenode/StackTraversePreorder.java)
```java
public void traverse(TreeNode root){
    if(root == null) return;

    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()){
        TreeNode node = stack.pop();
        print(node); // 前序遍历
        if(node.right != null) stack.push(node.right); // 先压右再压左。
        if(node.left != null) stack.push(node.left);
    }
}
```
## 2.2 深度优先之迭代-中序
[code](../../javademo/treenode/StackTraverseInorder.java)
```java
public void traverse(TreeNode){
    if(root == null) return;

    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while(!stack.isEmpty() || cur != null){
        while(cur != null){
            stack.push(cur);
            cur = cur.left;
        }

        if(!stack.isEmpty()){
            cur n = stack.pop();
            // do somebusiness with n like print(n)
            cur = n.right;
        }
    }
}
```
## 2.3 深度优先之迭代-后序
[code](../../javademo/treenode/StackTraversePostorder.java)
- 前序遍历是根-左-右，后序遍历是左-右-根。
- 方法1，双栈，第一个栈用于实现：根-右-左，然后借助第二个栈进行倒序为：左-右-根
```java
public void postorder(TreeNode root){
    if(root == null) return;

    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    Stack<TreeNode> reverse = new Stack<>();
    TreeNode cur;
    while(!stack.isEmpty()){
        cur = stack.pop();
        reverse.push(cur);
        if(cur.left != null) stack.push(cur.left);
        if(cur.right != null) stack.push(cur.right);
    }

    while(!reverse.isEmpty()){
        cur = reverse.pop();
        // do some bussiness with cur like print();
    }
}
```
- 方法2，双端队列，使用双端队列来实现倒序。
```java
public void postorder(TreeNode root){
    if(root == null) return;

    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    LinkedList<TreeNode> reverse = new LinkedList<>();

    TreeNode cur;
    while(!stack.isEmpty()){
        cur = stack.pop();
        reverse.addFirst(cur);
        if(cur.left != null) stack.push(cur.left);
        if(cur.right != null) stack.push(cur.right);
    }

    for(TreeNode cur: reverse){
        // do some business with cur like print(); 
    }
}
```


## 3 广度优先之层序遍历-迭代
```Java
// BFS
public void traverse(TreeNode root){
    if(root == null) return;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode node = queue.poll();
        // print node
        // 
        // 
        if(node.left != null) queue.offer(node.left);
        if(node.right != null) queue.offer(node.right);
    }
}
```
或者需要区分层级的：
```java
public void traverse(TreeNode root){
    if(root == null) return;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int level = 0;
    while(!queue.isEmpty()){
        int size = queue.size();
        level++;
        while(size > 0){
            TreeNode node = queue.poll();
            size--;
            //print node
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
        }
    }
}
```

二叉树
```java
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
}
// DFS
void traverse(TreeNode root){
    if(root == null) return;
    traverse(root.left);
    traverse(root.right);
}
```

对于多叉树或者图来说，可以如下：
```java
class TreeNode{
    int val;
    TreeNode[] children;
}
// DFS
void traverse(TreeNode root){
    if(null == root) return;
    for(TreeNode node : root.children){
        traverse(node);
    }
}
```

## 3 层序遍历=广度优先BFS
属于线性遍历
```java
class TreeNode{
    int val;
    TreeNode[] children;
}
// DFS
void levelTraverse(TreeNode root){
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode cur = queue.poll();
        if(cur == null) continue;
        for(TreeNode child: cur.children()){
            queue.offer(child);
        }
    }
}
```

## 4 前序遍历缺点
前序遍历获取不到子节点的返回的信息或者说获取不到子问题的答案。

## 5 后序遍历的优点
后序遍历可以获得每个子问题（左子问题、右子问题）的结果，在最优子问题的场景下非常好用。


## 6 注意
我们不仅可以遍历一个具体的节点，甚至可以遍历每两个、三个、N个相邻节点。

而这个被遍历的对象就是作为递归的入参来着。有个例子：[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)，在这个例子中，就不是遍历每个节点，而是遍历两个相邻的节点，于是乎：

```Java
void link(TreeNode root){
    traverse(root.left, root.right);
}


void traverse(TreeNode n1, TreeNode n2){
    n1.next = n2;
    traverse(n1.left, n1.right);
    traverse(n2.left, n2.right);
    // 下面这一行才是重中之重呀。
    traverse(n1.right, n2.left);
}
```

## 7 参考

1. 非常重要的参考：[东哥带你刷二叉树（纲领篇） :: labuladong的算法小抄 (gitee.io)](https://labuladong.gitee.io/algo/2/19/33/)

# 核心思想

1. 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。
2. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，需要思考：如果单独抽出一个二叉树节点（这里既可以是具体的节点、也可以是虚拟的节点，虚拟节点有点意思，见【填充右侧指针】），它需要做什么事情？需要在什么时候（前/中/后序位置）做？**其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作**（在这之前，一直被这个问题困扰)。

上述核心思想多读几遍。

```Java
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
}

void traverse(TreeNode p){
    // doSomethingWithCurrentNode() 如果逻辑在这里，叫做【前序】遍历
    // 很显然，在这里还不拿不到子节点的信息。
    traverse(p.left);
    // doSomethingWithCurrentNode() 如果逻辑在这里，叫做【中序】遍历
    traverse(p.right);
    // doSomethingWithCurrentNode() 如果逻辑在这里，叫做【后序】遍历
    // 很显然，这里能够获得子节点（子问题的信息）
}

```

举一些具体的例子来说明前、中、后序遍历。

假设现在有一颗二叉搜索树，如果需要将所有元素【升序】打印，那么可以使用【中序遍历】

```Java
// 升序打印
void printAsc(TreeNode p){
    // 先做递归结束条件判断
    if (null == p){
        return;
    }
    // 因为 左子节点 < 父节点，所以应该先处理【打印】左子节点
    printAsc(p.left);
    // 因为父节点 > 右子节点，所以这里应该处理【打印】本节点（父节点）
    // 你看，打印的逻辑在【夹在中间】，所以，叫做中序遍历。
    print(p.val);
    // 最后再处理右子节点。
    printAsc(p.right)
}

// 降序打印
void printDesc(TreeNode p){
    // 先做递归结束条件判断，是一个好习惯。
    if ( null == p) {
        return;
    }
  
    // 根据二叉搜索树的性质，左子节点 < 父节点 < 右子节点，那么如果需要倒叙排序的话，先处理右子节点
    printDesc(p.right);
    // 还是使用的【中序遍历】
    print(p.val);
    // 再打印较小的左子节点。
    printDesc(p.left);
}

```

再来看两个例子：【快速排序】和【归并排序】

# 二叉树问题
题库：https://leetcode.cn/tag/binary-tree/problemset/

## 相同树
https://leetcode.cn/problems/same-tree/description/

```java
public boolean isSameTree(TreeNode p, TreeNode q){
    if(p == null && q == null) return true; // base，两个都为null的情况
    if(q == null || q == null) return false; // breaker，一个为null的情况
    return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); // 两个都不为null的情况。
}
```

## 镜像树
https://leetcode.cn/problems/symmetric-tree/
> Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

其实这个是**相同树**的翻版，判断左右子树是否镜像相等。
```java
public boolean isSymmetric(TreeNode left, TreeNode right){
    if(left == null && right == null) return true;
    if(left == null || right == null) return false;
    return (left.val == right.val) && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);
}
```
[code](../../javademo/treenode/SymmetricTree.java)

## 填充右侧指针【虚拟节点】

[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```Java
// 这个例子说明【虚拟节点】
// 如果是非虚拟节点，那么一般会traverse两次，分别是traverse(left)，traverse(right)
void connect(Node root){
    if (root == null) return;
    link(root.left, root.right);
}
void link(Node n1, Node n2){
    // 递归结束条件，任一节点为null即结束
    if (n1 ==null || n2 == null) return;
    n1.next = n2;
  
    link(n1.left, n1.right);
    link(n2.left, n2.right);

    // 重点在这一行
    link(n1.right, n2.left);
}
```

## 二叉树的右视图
https://leetcode.cn/problems/binary-tree-right-side-view/description/

使用层序遍历，关键在于如何找到每一层的最后一个节点。普通层序遍历做不到，需要稍微变动一下。每次进入while循环的时候，其实queue.size就是这一层的长度。也可以用这个方法来计算树的深度。
```java
public List<Integer> rightSideView(TreeNode root){
    List<Integer> res = new ArrayList<>();
    //base
    if(root == null) return res;

    Queue<TreeNode> queue = new LinkedQueue<>();
    queue.offer(root);
    int val = 0;
    while(!queue.isEmpty()){
        int cnt = queue.size();// the length of this level
        while(cnt > 0){
            TreeNode node = queue.poll();
            cnt--;
            val = node.val;
            if(node.left != null) queue.offer(node.left);
            if(node.right != null) queue.offer(node.right);
        }
        res.add(val);
    }
    return res;
}
```

## 展开为简单链表

[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/submissions/)
1. 使用后序遍历，意思是，先把左右两个分支先拉直。
2. 后序遍历的往往需要对子问题的结果进行计算
3. 子问题的解不一定需要通过return的方式返回，也可以使用**引用**返回
4. 当把左右子树拉直之后，就需要对当前树进行拉直。
```
     5
   3   4
     2   1
       1  1
```
拉直变为
```
    5
      3
        2
          1
            4
              1
                1
```

```Java
void flattern(Node root){
    if(root == null) return;
  
    flattern(root.left);
    flattern(root.right);
  
    Node left = root.left;
    Node right = root.right;
  
    root.left = null;
    root.right = left;
  
    // 重点在这里。
    Node p = root;
    while(p.right != null){
        p = p.right;
    }
    p.right = right;
}
```

## 展开为多层双向链表
https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/description/

1. 可以将child理解为左子树，next理解为右子树。
2. 使用后续遍历，先将左右子树flatten之后再flatten当前节点。
3. 注意维护双向关系。

[code](../../javademo/treenode/Flatten2.java)

```java
public Node flatten(Node head){
    if(head == null) return null;

    flatten(head.child);
    flatten(head.next);

    Node child = head.child;
    Node next = head.next;
    if(child != null){
        head.next = child;
        head.next.prev = head;// doubly linked
        head.child = null;

        Node p = child;
        while(p.next != null){
            p = p.next;
        }
        p.next = next;
        if(next != null){
            p.next.prev = p; // doubly linked
        }
    }
    return head;
}
```



## 二叉树剪枝
https://leetcode.cn/problems/pOCWxh/
题目描述那么复杂，其实就是剪去值为0的叶子节点。
[code](../../javademo/treenode/PruneTree.java)

```java
public TreeNode pruneTree(TreeNode root){
    if(root == null) return null;

    root.left = pruneTree(root.left);
    root.right = pruneTree(root.right);

    if(root.val == 0  && root.left == null && root.right == null){
        return null;
    }
    return root;
}
```

## 找树左下角的值
https://leetcode.cn/problems/find-bottom-left-tree-value/description/
寻找最深的、最左侧的节点。
- 方法一，递归，根据深度进行判断。
- 方法二，层序遍历，**先右子树再左子树**，最后的元素就是解。牛逼啊！！！

[code](../../javademo/treenode/FindBottomLeftValue.java)

## 公交路线TODO
https://leetcode.cn/problems/bus-routes/description/


## 拆分二叉搜索树TODO
https://leetcode.cn/problems/split-bst/description/


## 斐波那契树的移除子树游戏TODO
https://leetcode.cn/problems/subtree-removal-game-with-fibonacci-tree/description/
额，会员专属

## 合法二叉搜索树TODO
https://leetcode.cn/problems/legal-binary-search-tree-lcci/description/

## 在二叉树中增加一行TODO
https://leetcode.cn/problems/add-one-row-to-tree/description/

## 二叉树的最近公共祖先1
LCA(lowest common ancestor)

[一文秒杀 5 道最近公共祖先问题 ](https://mp.weixin.qq.com/s/njl6nuid0aalZdH5tuDpqQ)

- 元素不重复，而且q和q一定存在。

```Java
// 
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){
    if(root == null || p == null || q == null) return null;
    if(root.val == p.val || root.val == q.val){
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left != null && right != null){
        return root;
    }
    return left != null? left: right;
}
```

- 元素不重复，p、q不一定存在，如果不存在则返回null

```Java
// 。
// 因为要了解p和q存在不存在，所以需要进行后序遍历以保证所有的节点都被访问到。
boolean foundP = false;
boolean foundQ = false;
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){
    TreeNode res = traverse(root, p, q);
    if(foundP && foundQ){
        return res;
    }
    return null;
}
TreeNode traverse(TreeNode root, TreeNode p, TreeNode q){
    if(root == null) return null;
  
    TreeNode left = traverse(root.left, p, q);
    TreeNode right = traverse(root.right, p, q);
  
    if(left != null && right != null){
        return root;
    }
  
    // 核心在这里。
    if (root.val == p.val || root.val == q.val){
        if(root.val == p.val){
            foundP = true;
        }else (root.val == q.val){
            foundQ = true;
        }
        return root;
    }
  
    return left != null? left: right;

}
```

- 如果是在BST中查找最近公共祖先？？
  - 根据BST的性质，假设节点是目标节点的lca，那么一定要满足以下条件：
  - min(p, q) <= lca <= max(p, q);

## 二叉搜索树的最近公共祖先 
- 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```Java

TreeNode lca(TreeNode root, TreeNode p, TreeNode q){
     int min = Math.min(p.val, q.val);
     int max = Math.max(p.val, q.val);
     return lca(root, min, max);
}
TreeNode lca(TreeNode root, int min, int max){
    if(root == null) return null;
    if(root.val > max){
        return lca(root.left, min, max);
    }else if(root.val < min){
        return lca(root.right, min, max);
    }
    return root;
}
```

## 二叉树的最近公共祖先2TODO
https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/description/


## 重复子树
https://leetcode.cn/problems/find-duplicate-subtrees/

1. 后序遍历：可以知道以当前子树是树是怎么样的（前序遍历和中序遍历都做不到）。
2. 序列化：序列化之后可以用字符串相等判断树是否相同。

```Java
Map<String, Integer> subTrees = new HashMap<>();
List<TreeNode> res = new LinkedList<>();

String traverse(TreeNode root){
    if ( root == null) {
        return "#";
    }
  
    String left = traverse(root.left);
    String right = traverse(root.right);
  
  
    // 使用分隔符来区分两个1的节点和一个11的节点这种情况。
    String tree = root.val + "," + left + ","  + right;
  
  
    int count = subTrees.getOrDefault(tree, 0);
    if (count == 1){
        // 只有第一次出现重复的时候才加入结果集，避免重复三次或者更多次的场景下返回重复结果集
        // 当然也可以使用Set<TreeNode>来去重，但是如果题目要求返回的是List，则只能通过这种办法
        res.add(root);
    }
    subTrees.put(tree, count++);
    return tree;
}
```

## 归并排序

使用二叉树思想来处理数组的排序问题，关键在于入参不再是节点，而是数组。如何确定当前处理的树大小呢？加上索引范围lo和hi就可以了，子问题

1. 后序遍历的思想
2. 借助辅助变量完成合并。

```Java
int[] help;
void mergeSort(int[] nums){
    help = new int[nums.length];
    traverse(nums, 0, nums.length-1);
    return nums;
}

// 使用后序遍历框架
void traverse(int[] nums, int lo, int hi){
    if(lo == hi) return;
    int mid = (lo + hi)/2;
    traverse(nums, lo, mid);
    traverse(nums, mid+1, hi);
    merge(nums, lo, mid, hi);
}

// 做合并需要一个辅助数组help
// 现将nums[lo:hi]复制给help
// 指针p指向nums[lo]，依次填充值（其实是修改值）
// 具体填哪个值呢？有两个指针left和right分别指向左半部分的起点help[lo]和help[mid+1]
// help[lo]和help[mid+1]哪个值小就填到nums[p]中，然后移动对应的指针。
void merge(int[] nums, int lo, int mid, int hi){
    for(int i = lo; i <=hi; i++){
        help[i] = nums[i];
    }
  
    int left = lo;
    int right = mid + 1;
    for(int p = lo; p <=hi; p++){
        if(left == mid + 1){
            nums[p] = tmp[right++];
        }else if (right == hi + 1){
            nums[p] = tmp[left++];
        }else if (tmp[left] < tmp[right]){
            nums[p] = tmp[left++];
        }else {
            nums[p] = tmp[right++];
        }
    }
}
```

## 计算右侧小于当前元素的个数

TODO这道题好难啊

[归并排序详解及应用 :: labuladong的算法小抄 (gitee.io)](https://labuladong.gitee.io/algo/2/19/38/)

```Java

```

## 翻转对TODO

## 区间和的个数TODO

## 二叉树的层序遍历
https://leetcode.cn/problems/binary-tree-level-order-traversal/description/

>Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

1. List<List<Integer>>，从上到下，从左到右，依次将树放置到这个List中，跟一般的层序遍历不太一样。
2. 方法一：传统层序遍历，每一层建一个List<Integer>
3. 方法二：DFS，根据深度找到所在层的List<Integer>

[code](../../javademo/treenode/LevelOrderTraversal.java)

## 二叉树的层序遍历2
https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/

- 经典层序遍历，只不过`List<List<Integer>>`改为使用`LinkedList<List<Integer>>`，然后`res.add(list)`改为`res.addFirst(list)`即可。


## 二叉树的锯齿型层序遍历
https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/

>Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).

- ~~使用两个双端队列deque，放入的时候，都是deque.offerLast()，取的时候，根据方向或取头deque.pollFirst()，或取尾deque.pollLast()~~，这个思路有错误。无法处理`1, 2, 3, 4, -1, -1, 5`
- 暂时使用这个结构来计算：`List<Deque<Integer>> `，每一层使用不同的入列方向，或deque.offerLast()，或deque.offerFirst()。然后将deque转为ArrayList即可。
- 变化入列方向：fromLeft = !fromLeft

[code](../../javademo/treenode/LevelOrderZigzagTraversal.java)

```java
public List<List<Integer>> zigzagTraversal(TreeNode root){
    List<List<Integer>> res = new ArrayList<>();
    if(root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    boolean fromLeft = true;

    while(!queue.isEmpty){
        int size = queue.size();
        Deque<Integer> deque = new LinkedList<>();
        while(size > 0){
            TreeNode cur = queue.poll();
            size--;
            if(fromLeft){
                deque.offerLast(cur.val);
            }else{
                deque.offerFirst(cur.val);
            }

            if(cur.left != null) queue.offer(cur.left);
            if(cur.right != null) queue.offer(cur.right);
        }

        List<Integer> list = new ArrayList<>();
        while(!deque.isEmpty()){
            list.add(deque.poll());
        }
        res.add(list);
        
        fromLeft = !fromLeft;
    }
    return res;
}
```

## 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/

>Given the root of a binary tree, return its maximum depth.
>A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

- DFS，后序遍历，max(左子树的深度，右子树的深度）+ 1 就是当前子树的深度。

[code](../../javademo/treenode/MaxDepth.java)
```java
public int maxDepth(TreeNode root){
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```
## 平衡二叉树
https://leetcode.cn/problems/balanced-binary-tree/

>Given a binary tree, determine if it is height-balanced，一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

[code](../../javademo/treenode/BalanceTree.java)

## 路径总和
> Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

> A leaf is a node with no children.

- 总和可以是从叶子到root逐渐累加，也可以是从root到leaf的逐渐递减。
- ~~如果自下而上的累加，需要递归函数return累加值，也就是至少需要两个函数才能解出来。~~这条路行不通。
- **如果自上而下的递减，剩余值可以通过参数传递下去，那么只需要一个函数就可以解出来，更加简约。自上而下就是前序遍历**

[code](../../javademo/treenode/PathSum.java)

## 路径总和ii
https://leetcode.cn/problems/path-sum-ii/

> Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.
> A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.

1. 自上而下（前序遍历），使用回溯。但是下面这种方式有**重复解**：5,4,8,11,null,13,4,7,2,null,null,5,1 > [[5,4,11,2],[5,4,11,2],[5,8,4,5],[5,8,4,5]]，因为叶子节点会分别进行左右两个null子节点的计算，所有会有重复解。
```java
private List<List<Integer>> res = new ArrayList<>();
public List<List<Integer>> pathSum(TreeNode root, int targetSum){
    LinkedList<Integer> path = new LinkedList<>();
    backtracing(root, targetSum, path);
    return res;
}
private void backtracing(TreeNode node, int targetSum, LinkedList<Integer> path){
    if(root == null) {
        if(targetSum == 0){
            res.add(new ArrayList<>(path));
        }
        return;
    };
    path.addLast(node.val);
    targetSum -= node.val;
    
    backtracing(node.left, targetSum, path);
    backtracing(node.right, targetSum, path);

    path.removeLast();
}
```

1. 为了避免重复解，应该在叶子节点就要做判断。
[code](../../javademo/treenode/PathSum2.java)
```java
private void backtracing(TreeNode node, int targetSum, LinkedList<Integer> path){
    if(root == null) return;
    
    path.addLast(node.val);
    targetSum -= node.val;
    if(targetSum == 0 && node.left == null && node.right == null){ 
        // 在叶子节点判断解而不是在null节点。
        res.add(new ArrayList<>(path));
    }
    
    backtracing(node.left, targetSum, path);
    backtracing(node.right, targetSum, path);

    path.removeLast();
}
```

## 二叉树中的最大路径和-hard
https://leetcode.cn/problems/binary-tree-maximum-path-sum/
> A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
> The path sum of a path is the sum of the node's values in the path.
> Given the root of a binary tree, return the maximum path sum of any non-empty path.


1. 大问题转为小问题，我们来看一颗只有三个节点的子树。那么解有以下六种情况：
    - root + left + right
    - root + left
    - root + right
    - root
    - left
    - right
2. 在这六种情况中，可以跟更大的树连接的有：
    - root + left
    - root + right
    - root
3. 其他三种情况都不能跟更大的树连接，那么他们就构成了备选解，这个备选解跟最大树的解取较大值就是最终解。
    - root + left + right
    - left
    - right
4. 注意对叶子节点的处理！！！比如[-3]这种情况
[code](../../javademo/treenode/MaxPathSum.java)

```java
private int tmp;
public int maxPathSum(TreeNode root){
    tmp = Integer.MIN_VALUE;
    int max = dfs(root);
    return Math.max(tmp, max);
}
private int dfs(TreeNode root){
    if(root == null) return 0; 

    int leftMax = dfs(root.left);
    int rightMax = dfs(root.right);
    int max = Integer.MIN_VALUE;
    max = Math.max(max, root.val + leftMax);
    max = Math.max(max, root.val + rightMax);
    max = Math.max(max, root.val);

    //其他备选解
    tmp = Math.max(tmp, root.val + leftMax + rightMax);
    if(leftMax != 0) tmp = Math.max(tmp, leftMax); // 对叶子节点的特殊处理。
    if(rightMax != 0) tmp = Math.max(tmp, rightMax);

    return max;
}
```

## 根节点到叶子节点数字之和
https://leetcode.cn/problems/sum-root-to-leaf-numbers/

[code](../../javademo/treenode/SumNumbers.java)

1，当前层=上一层*10 + 当前层
```java
int sum;
public int sumNumbers(TreeNode root){
    dfs(root, 0);
    return sum;
}
private void dfs(TreeNode root, int curSum){
    if(root == null) return;
    int curSum = curSum * 10 + root.val;
    if(root.left == null && root.right == null){
        sum += curSum;
        return;
    }
    dfs(root.left);
    dfs(root.right);
}
```

## 打家劫舍3 TODO 
https://leetcode.cn/problems/house-robber-iii/

>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.
>
>Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.
>
>Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.


## 左叶子之和
https://leetcode.cn/problems/sum-of-left-leaves/
[code](../../javademo/treenode/SumofLeftLeaves.java)

都可以通过遍历一遍树得到结果，分别有两个方法：
1. 自上而下+全局辅助变量实现。
2. 自下而上，层层递归结果。如：
```java
public int sum(TreeNode root){
    return bottomsUp(root, false);
}
private int bottomsUp(TreeNode node, isLeft){
    if(root == null) return 0;
    int left = bottomssUp(node.left, true);
    int right = bottomsUp(node.right, false);
    if(isLeft && node.left == null && node.right == null){
        return node.val;
    }
    return left + right;
}
```
## 构造二叉树1-最大二叉树
https://leetcode.cn/problems/maximum-binary-tree/
- 核心思想：先构造根节点，再构造左子树和右子树
- 关键点：掌握左子树和右子树的分界点或者说左子树和右子树的长度。
- 找数组到最大值，其左边元素构造左子树，其右边元素构造右子树。

```java
TreeNode constructMaximumBinaryTree(int[] nums){
    return build(nums, 0, nums.length);
}

private TreeNode build(int[] nums, int start, int end){
    if(start >= end){
        return null;
    }
    int maxVal = Integer.MIN_VALUE;
    int maxValIndx = -1;
    for(int i = start; i < end; i++){
        int val = nums[i];
        if(val > maxVal){
            maxVal = val;
            maxValIndx = i;
        }
    }
    Node node = new TreeNode(nums[maxValIndx]);
    node.left = build(nums, start, maxValIndx);
    node.right = build(nums, maxValIndx + 1, end);

    return node;
}
```

```python
def constructMaximumBinaryTree(self, nums):
    if not nums: 
        return None
    def build(nums):
        if nums == []:
            return None
        maxVal = max(nums)
        maxIdx = nums.index(maxVal)
        root = TreeNode(maxVal, None, None)
        root.left = build(nums[:maxIdx])
        root.right = build(nums[maxIdx+1:])
        return root
    return build(nums)
```

## 构造二叉树2-最大二叉树
https://leetcode.cn/problems/maximum-binary-tree-ii/description/

> A maximum tree is a tree where every node has a value greater than any other value in its subtree.
> 
>You are given the root of a maximum binary tree and an integer val.
>
>Just as in the previous problem, the given tree was constructed from a list a (root = Construct(a)) recursively with the following Construct(a) routine:
>
>If a is empty, return null.
>Otherwise, let a[i] be the largest element of a. Create a root node with the value a[i].
>The left child of root will be Construct([a[0], a[1], ..., a[i - 1]]).
>The right child of root will be Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]).
>Return root.
>Note that we were not given a directly, only a root node root = Construct(a).
>
>Suppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values.
>
>Return Construct(b).

[code](../../javademo/treenode/MaximumBinaryTree2.java)

1. if val is greater than root.val, then val should be the new root, and old root should be left sub tree.
2. if val is less than root.val, then insert the val into the right sub tree.

```java
public TreeNode insertIntoMaxTree(TreeNode root, int val){
    if(root == null) return new TreeNode(val);
    
    if(val > root.val){
        TreeNode newRoot = new TreeNode(val);
        newRoot.left = root;
        return rewRoot;
    }else{
        root.right = insertIntoMaxTree(root.right, val);
        return root;
    }
}
```


## 构造二叉树3-前序中序
https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]

- 关键是找到root以及左右子树
- 前序遍历的第一个元素始终是根节点，
- 得到跟节点之后，在中序遍历中，根节点之前的是做子树、根节点之后的右子树。
- 如果对下标、长度之间的转换关系把握不住，那么就画个图，比如：
前序遍历的下标：0 1 2 3 4 5 
中序遍历的下标：0 1 2 3 4 5
假设中序遍历中，根节点的下标是3，那么得到左子树的长度也是3：[0,1,2]，于是得到递归的
```python
def buildTree(preorder, inorder):
    root = TreeNode(preorder[0])
    r_idx = inorder.index(root.val)
    left_length = r_idx

    root.left = buildTree(preorder[1:left_length + 1], inorder[:left_length])
    root.right = buildTree(preorder[left_length + 1:], inorder[left_length + 1:])
    return root
```
```Java
// 辅助Map
Map<Integer, Integer> inorderMap = new HashMap<>();

void buildTree(int[] preorder, int[] inorder){
    for(int i = 0; i < inorder.length; i++){
        inorderMap.put(inorder[i], i);
    }
  
    return doBuild(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);
}

// 使用【左闭右闭】的风格进行【区间分治】，更容易理解。
TreeNode doBuild(int[] preorder, int preStart, int preEnd, 
              int[] inorder, int inStart, int inEnd){
    // base case
    if (preStart > preEnd) return null;
  
    // build root，前序的第一个元素是根节点。
    int rootVal = preorder[preStart];
    TreeNode root = new TreeNode(rootVal);
  
    // 尝试找到左子树的区间
    int x = inorderMap.get(rooVal);
    int leftSize = x - inStart;
  
    // build left
    int y = preStart + leftSize;
    int z = x - 1;
    root.left = doBuild(preorder, preStart + 1, y, inorder, inStart, z);
  
    // build right
    int a = y +1;
    int b = x + 1;
    root.right = doBuild(preorder, a, preEnd, inorder, b, inEnd);
  
    // return root
    return root;
}
```

![](https://secure2.wostatic.cn/static/kdQcyb4mf2aKqdGNQRk6iq/image.png)

## 构造二叉树4-中序后序
https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/

[code](../../javademo/treenode/BuildTree2.java)



---


# 序列化

【前序遍历】将二叉树转为字符串，并从字符串反序列化为二叉树。重点：
1. **如果是普通遍历的话，即没有记录null节点，那么是无法进行反序列化的，因为不知道左子树****结束点****，所以不同于普通遍历，序列化的遍历要记录好空节点。**
2. **序列化的思路跟遍历基本是一样的，只是多了null节点的处理。**
3. **反序列化的思路跟构造二叉树基本是一样的：先构造父节点，再依次构造左右子节点，**区别在于反序列化需要**通过空来判断左右子树分界点**。

## 前序遍历

```Java
String SEP = ",";
String NULL = "#";

// 序列化主函数
void String serialize(TreeNode root){
    if (root == null){
        return null;
    }
    StringBuilder sb = new StringBuiler();
    traverse(root, sb);
    return sb.toString();
}
// 序列化辅助函数
void traverse(TreeNode root, StringBuilder sb){
    // 递归结束
    if(root == null){
        sb.append(NULL);
        sb.append(SEP);
        return s
    }
  
    // 前序遍历 
    sb.append(root.val);
    sb.append(SEP);
  
    serialize(root.left, sb);
    serialize(root.right, sb);
}

// 反序列化主函数
TreeNode deserialized(String str){
    if (null == str) return;
    LinkedList<String> nodes = new LinkedList(Arrays.asList(str.split(SEP)));
    return traverse(nodes);
}
// 反序列化辅助函数
TreeNode traverse(LinkedList<String> nodes){
    if (nodes.isEmpty) return null;
  
    String root = nodes.removeFirst();
    if(root.equals(NULL)) return null;
  
    int val = Integer.parseInt(root);
    TreeNode root = new TreeNode(val);
    root.left = traverse(nodes);
    root.right = traverse(nodes);
    return root;
}
```

## 中序遍历，不支持

## 后序遍历

```Java

```

## 层序遍历

层序遍历的序列化和反序列化是比较不好掌握的东西，要多研究。

```Java
// 序列化，在基本层序遍历的基础之上做一点小小改动。
String serialize(TreeNode root){
    if (root == null) return null;
  
    StringBuilder sb = new StringBuiler();
  
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
  
    while(!queue.isEmpty()){
  
        TreeNode current = queue.poll();
        // 普通层序遍历中，queue是不会有null元素的。
        // 但是在序列化的场景之下，会有可能出现null元素。
        if (current == null){
            sb.append(NULL).append(SEP);
            continue;
        }
      
        sb.append(current.val).append(SEP);
      
        // 将null子树也放到队列中。
        queue.offer(current.left);
        queue.offer(current.right);
    }
}

// 反序列化【 重点 】
TreeNode deserialize(String data){
    if(data == null) return null;
  
    String[] nodes = data.split(SEP);
  
    TreeNode root = new TreeNode(nodes[0]);
    Queue<TreeNode> queue = new LinkedQueue<>();
    queue.offer(root);
  
    for(int i =1; i < nodes.length; ){
        // 这个队列里面不会有元素。
        // 队列里的元素不为空。
        // 每一个节点都要从nodes中依次使用两个元素分别作为左子节点和右子节点。
        // 所以每一个从队列poll出来的元素要对应两次i++
        TreeNode parent = queue.poll();
      
        String left = nodes[i++];
        if(!left.equals(NULL)){
            parent.left = new TreeNode(Integer.parseInt(left));
            queue.offer(parent.left);
        }
      
        String right = nodes[i++];
        if(!right.equals(NULL)){
            parent.right = new TreeNode(Integer.parseInt(right));
            queue.offer(parent.right);
        }
    }
    return root;
}
```

## 题目 hard
https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/

[code](../../javademo/treenode/Codec.java)


## 验证二叉树的前序序列化-hard
https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/
> preorder consist of integers in the range [0, 100] and '#' separated by commas ','.

[code](../../javademo/treenode/CheckSerialization.java)

- 牢牢抓住“一个叶子节点对应两个井号”的性质。
- 对序列化字符串进行倒叙遍历，遇到一个数字，就一定要有两个井号与之对应，这个子树就合法了，然后这个子树转为一个#号继续遍历。

```java
public boolean isValidSerialization(String preorder){
    if(preorder == null) return true;
    int cnt = 0;
    for(int i = preorder.length() -1; i >= 0; i--){
        char c = preorder.charAt(i);
        if(c == ',') continue; // 逗号不管。

        if(c == '#'){ // 井号+1
            cnt++;
            continue;
        }

        if(i > 0 && preorder.charAt(i - 1) != ','){// 遇到数字，可能是1位数，2位数，或3位数。
            i--;
        }

        if(cnt < 2) return false; // 遇到一个数字，至少要有两个井号与之匹配。

        cnt--; // 匹配之后，一个子树变成一个#号。
    } 

    return cnt == 1; // 最后的井号肯定归1
}
```

# 二叉搜索树BST

## 框架
遍历框架如下：
```Java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

构建框架，构建左子树，构建右子树，构建root，返回root、
```java
TreeNode insertBST(TreeNode root, int val){
    // 如果这个子树是空的，那么以val为root构建，并返回。
    if(root == null) return new TreeNode(val);

    // 如果val大于当前子数根的val， 那么val应该插入到右子树中。
    if(val < root.val){
        root.left = insertBST(root.left, val);
        return root;
    }

    if(val > root.val){
        root.right = insertBST(root.right, val);
        return root;
    }
    // root.val == val
    return root;
}
```



## 寻找第 K 小的元素
https://leetcode.cn/problems/kth-smallest-element-in-a-bst/

1. 使用中序遍历（升序）
2. 使用全局变量辅助，事件复杂度O(N)，但是BST一般都能够优化成为O(logN)，一般一般。

```Java
int res;
int cnt;
int findKSmall(TreeNode root, int k){
    traverse(root, k);
    return res;
}
void traverse(TreeNode root, int k){
    if(root == null) return;
    traverse(root.left, k);
    if(++cnt == k){
        res = root.val;
    }
    traverse(root.right, k);
}
```

附加
> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?



## BST转为累加树

每个节点的新值都是原本树中大于等于这个节点的数的和（降序遍历）。

或者：每个节点的新值都是原本树中小于等于这个节点的数的和（升序遍历）。

1. 中序遍历（降序）

```Java
int sum;
TreeNode convert(TreeNode root){
    if(root ==null) return null;
    convert(root.right);
    sum += root.val;
    root.val = sum;
    convert(root.left);
}


```

## 判断合法性

1. 以root为界，判断左子树，判断右子树。
2. 前序遍历：那么当前节点作为左子树的上限；同时也是右子节点的下限。


```Java
boolean valid(TreeNode root){
    // 根节点没有上界、也没有下界。
    return valid(root, null, null);
}
boolean valid(TreeNode root, TreeNode max, TreeNode min){
    if(root == null) return true;
    // 前序遍历，如果这个节点有上界或者下届，则进行判断
    if(max != null && root.val >= max.val){
        // 如果超过上界，则返回false，熔断。
        return false;
    }
    if(min != null && root.val <= min.val){
        // 如果低于下界，则返回false，熔断，不对它的子树进行判断。
        return false;
    }
  
    // 当前节点作为左子树的上界，下界不变。
    // 当前节点作为右子树的下界，上界不变。
    return valid(root.left, root, min) && valid(root.right, max, root);
}
```

2）中序遍历（利用BST和升序和降序特性）

```Java
boolean res = true;
TreeNode prev = null;
boolean valid(TreeNode root){
    if(root == null) return res;
    valid(root.left);
  
    // 中序遍历，使用当前的节点跟上一个节点比较，如果小于之前的节点，则违法了BST的升序规则。
    if ( prev != null && root.val <= prev.val){
        res = false;
    }
    prev = root;
  
    valid(root.right);
    return res;
}
```

## 增

```Java
TreeNode add(TreeNode root, int val){
    if(root == null){
        root = new TreeNode(val);
    }else if (val < root.val){
        add(root.left, val);
    }else {
        add(root.right, val);
    }
    return root;
}
```

## 删

1. 如果被删节点没有子节点，直接删除。
2. 如果被删除的节点只有一个子节点，删除本节点之后，子节点顶上。
3. 如果被删除的节点有两个子节点，那么左子树中最大的子节点顶替或者右子树的最小子节点顶上。因为左子树的最大节点顶上之后仍然满足比左子树都大、比右子树都小。右子树的最小节点顶上是同一个道理。
4. 如果左子树顶上，那么右子树要放到左子树的right.right....末尾。
5. 如果右子数顶上，那么左子树要放到右子树的left.left....末尾。


```Java
TreeNode delete(TreeNode root, int val){
    if (root == null) return null;
    if (root.val == val){
        // 找到，进行替换。
      
        // 覆盖第1、第2种情况
        if (root.left == null ){
            return root.right;
        }
        if (root.right == null ){
            return root.left;
        }
      
        // 第3种情况
        TreeNode minNode = findMin(root.right);
        root.right = delete(root.right, minNode.val);
        minNode.left = root.left;
        minNode.right = root.right;
        root = minNode;
      
    } else if (val < root.val){
        root.left = delete(root.left, val);
    } else{
        root.right = delete(root.right, val);
    }
    return root;
}
// 寻找最小的节点。
TreeNode findMin(TreeNode root){
    while(root.left != null){
        root = root.left;
    }
    return root;
}
```

## 改

删除+插入。

## 查

- 当做普通二叉树进行遍历（前序、中序、后序、层序）O(N)
- 或者利用BST的特性，O(logN)

```Java
void visit(TreeNode root, int target){
    if(root == null) return ;
    if(root.val == target){
        sout("hit");
    }else if(target < root.val){
        visit(root.left, target);
    }else{
        visit(root.right, target);
    }
}
```

## 有序数组转为二叉搜索树
https://leetcode.cn/problems/unique-binary-search-trees-ii/

>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

1. mid = left + (right - left)/2;

```java
public TreeNode build(int[] arr){
    return doBuild(arr, 0, arr.length -1);//左闭右闭
}
private TreeNode doBuild(int[] arr, int left, int right){
    if(arr == null || arr.length == 0 || left > right) return null;

    int mid = left + (right - left)/2;
    TreeNode root = new TreeNode(arr[mid]);
    root.left = doBuild(arr, left, mid -1);
    root.right = doBuild(arr, mid + 1, right);
    return root;
}
```

## 有序链表转为二叉搜索树

> Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.

1. 方法一，将链表转为数组，然后再构建BST
2. 方法二，使用快慢指针找到mid，额外pre变量，用来记录slow的pre，用来断链。
```java
ListNode fast = head;
ListNode pre = head;
ListNode slow = head;
while(fast != null && fast.next != null){
    fast = fast.next.next;
    pre = slow; 
    slow = slow.next; // mid
}
pre.next = null; // 断链

TreeNode root = new TreeNode(slow.val);
root.left = traverse(head);
root.right = traverse(slow.next);
```

## 不同的二叉搜索树
https://leetcode.cn/problems/unique-binary-search-trees/

1. 动态规划的思想（大问题转为子问题）：所有构成 = 左子树的所有构成 * 右子树的所有构成
2. BST的特性：根节点始终大于左子树任意节点；根节点始终小于右子树任意节点。

```Java
// 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？
// 返回满足题意的二叉搜索树的种数。
int numTrees(int n){
    // 或者count(1, n);
    return count(0, n - 1);
}
int count(int lo, int hi){
    if(lo > hi){
        return 1;
    }
  
    int res = 0;
    for(int i = lo; i <= hi; i++){
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        res += left * right;
    }
    return res;
}
// 上述方法存在重复子问题。解决方式二选一：1）使用全局变量记录结果；2）不使用递归。
// 1）
int[][] memo;
int numTrees(int n){
    memo = new int[n][n];
    return count(0, n-1);
}
// 以[lo, hi]左闭右闭区间子树有多少种构型？
int count(int lo, int hi){
    if(lo > hi){
        return 1;
    }
    if (memo[lo][hi] != 0){
        return memo[lo][hi];
    }
  
    int res = 0;
    for(int i = lo; i <= hi; i++){
        int left = count(lo, i-1);
        int right = count(i+1, hi);
        res += left * right;
    }
    memo[lo][hi] = res;
    return res;
}
// 不适用递归的话，就要转到状态转移方程，
// 假设F(n)表示n个数构成的BST总数，那么F(n)跟F(n-1)或者F(n-2)等有什么关系？TODO
```

## 不同的二叉搜索树 II
https://leetcode.cn/problems/unique-binary-search-trees-ii/

1. 这题跟上一题的思路很像，不同的是上题返回的是int表示这个闭区间的子树个数。
2. 那么这道题就应该返回List<TreeNode>来表示每个闭区间的子树对象。

```Java
List<TreeNode> generateTrees(int n){
    return build(0, n-1);
}

List<TreeNode> build(int lo, int hi){
    List<TreeNode> res = new LinkedList();
    if(lo > hi){
        res.add(null);
        return res;
    }
  
    for(int i = lo; i<=hi; i++){
        List<TreeNode> leftTrees = build(lo, i-1);
        List<TreeNode> rightTrees = build(i+1, hi);
      
        for(TreeNode left: leftTrees){
            for(TreeNode right: rightTrees){
                // 记住i是下标，i+1才是其值。
                TreeNode root = new TreeNode(i + 1);
                root.left = left;
                root.right = right;
                res.add(roo);
            }
        }
    }
  
    return res;
}
```

## 快排

```Java

```

## recover binary search tree
https://leetcode.cn/problems/recover-binary-search-tree/

> You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.

1. 仅仅把握住二叉搜索树的性质，左子树的所有节点总是比根节点小，右子树的所有节点总是比根节点大；中序遍历是升序。
2. 题目中有两个节点的顺序调换了，导致中序遍历不再是升序，即有**两个节点**不满足单调递增。比如3,1,4,2,5(层序遍历)进行中序遍历的时候是3,2,1,4,5，其中3,1不满足单调递增的要求，这两个节点就是错误的节点，交换他们的val即可。


## BST迭代器
https://leetcode.cn/problems/binary-search-tree-iterator/

两个方法：
1. 使用Queue，in-order的方式全部放入队列中。
2. 使用stack，初始化的时候，只将左子树放入堆栈；next的时候，再将右子树的左子树放入堆栈中。这个就是树的迭代遍历，见【2.2 深度优先之迭代-中序】
[code](../../javademo/treenode/BstIterator.java)
[code](../../javademo/treenode/BstIterator2.java)

# 其他树

[341. 扁平化嵌套列表迭代器 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-nested-list-iterator/submissions/)

1. 层序遍历
2. 恶汉模式

```Java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return empty list if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
 /**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i = new NestedIterator(nestedList);
 * while (i.hasNext()) v[f()] = i.next();
 */
 
 public class NestedIterator implement Iterator<Integer> {
     private Iterator<Integer> it;
     pubic NestedIterator(List<NestedInteger> nestedList){
         List<Integer> list = new LinkedList<>();
         if(nestedList == null || nestedList.isEmpty()){
             it = list.iterator();
         }else{
             for(NestedInteger n: nestedList){
                 traverse(n, list);
             }
         }
     }
     private void traverse(NestedInteger n, List<Integer> list){
         if( n == null){
             return;
         }
         if( n.isInteger()){
             list.add(n.getInteger());
         }else{
             for(NestedInteger ni: n.getList()){
                 traverse(ni, list);
             }
         }
     }
   
     @Override
     public boolean hasNext(){
         return it.hasNext();
     }
   
     @Override
     public Integer next(){
         return it.next();
     }
 }

```

3. 懒汉模式

```Java
 public class NestedIterator implement Iterator<Integer> {
   
     pubic NestedIterator(List<NestedInteger> nestedList){

     }

   
     @Override
     public boolean hasNext(){

     }
   
     @Override
     public Integer next(){

     }
 }
```

# tree affacted.
https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/description/
其实是找起始节点到其他节点的最远距离。
方法一：遍历一边，将每个节点的父节点信息存储起来。

